// Добавляем GSAP для анимаций
const gsap = window.gsap || {
    utils: {
        clamp: (min, max, value) => Math.min(Math.max(value, min), max)
    }
};

// Создаем общий загрузчик изображений
const imageLoader = {
    cache: new Map(),
    
    async load(url) {
        if (this.cache.has(url)) return this.cache.get(url);
        return new Promise(resolve => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                this.cache.set(url, img);
                resolve(img);
            };
            img.onerror = () => {
                console.error('Failed to load image:', url);
                resolve(null);
            };
            img.src = url;
        });
    }
};

// Функция для создания эффекта scrambling текста
function setupTextScrambleEffect() {
    // Добавляем стили для эффекта scrambling
    const style = document.createElement('style');
    style.textContent = `
        /* Изначально скрываем все текстовые элементы */
        [data-gallery-text="title"], 
        [data-gallery-text="author"] {
            visibility: hidden !important;
            opacity: 0 !important;
            transition: none !important;
        }
        
        /* Показываем только когда они готовы к анимации */
        .text-scramble-prepared[data-gallery-text]:not(.initial-animation *) {
            visibility: visible !important;
            opacity: 1 !important;
            transition: visibility 0.3s, opacity 0.3s !important;
        }
        
        /* Принудительно скрываем во время начальной анимации */
        .initial-animation [data-gallery-text] {
            visibility: hidden !important;
            opacity: 0 !important;
            transition: none !important;
        }
        
        .text-scramble-char {
            display: inline-block;
            position: relative;
            color: transparent;
        }
        
        .text-scramble-char::after {
            content: attr(data-char);
            position: absolute;
            left: 0;
            top: 0;
            color: white;
        }
        
        @keyframes textScramble {
            0%, 12% { content: attr(data-char-1); }
            25% { content: attr(data-char-2); }
            37% { content: attr(data-char-3); }
            50% { content: attr(data-char-1); }
            62% { content: attr(data-char-2); }
            75% { content: attr(data-char-3); }
            100% { content: attr(data-char); }
        }
        
        .text-scramble-active .text-scramble-char::after {
            animation: textScramble 1.2s calc(var(--char-index, 0) * 0.04s) forwards;
        }
    `;
    document.head.appendChild(style);
    
    // Функция для подготовки текста к эффекту scrambling
    function prepareTextForScramble(element) {
        if (!element || element.classList.contains('text-scramble-prepared')) return;
        
        const text = element.textContent.trim();
        const chars = text.split('');
        
        // Создаем временный контейнер для определения строк
        const tempContainer = document.createElement('div');
        tempContainer.style.cssText = `
            position: absolute;
            visibility: hidden;
            white-space: normal;
            width: ${element.offsetWidth}px;
        `;
        
        // Создаем спаны для каждого символа для определения их позиции
        chars.forEach(char => {
            const span = document.createElement('span');
            span.textContent = char;
            span.style.cssText = 'display: inline-block;';
            tempContainer.appendChild(span);
        });
        
        document.body.appendChild(tempContainer);
        
        // Получаем информацию о строках
        const spans = tempContainer.children;
        const lines = [];
        let currentLine = [];
        let lastTop = spans[0]?.getBoundingClientRect().top;
        
        Array.from(spans).forEach((span, index) => {
            const rect = span.getBoundingClientRect();
            if (rect.top !== lastTop) {
                lines.push(currentLine);
                currentLine = [];
                lastTop = rect.top;
            }
            currentLine.push(chars[index]);
        });
        if (currentLine.length > 0) {
            lines.push(currentLine);
        }
        
        document.body.removeChild(tempContainer);
        
        // Используем только буквы алфавита для промежуточных символов
        const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        
        // Создаем HTML для каждой строки
        const html = lines.map((line, lineIndex) => {
            return line.map((char, indexInLine) => {
                if (char === ' ') return ' ';
                
                const char1 = randomChars[Math.floor(Math.random() * randomChars.length)];
                const char2 = randomChars[Math.floor(Math.random() * randomChars.length)];
                const char3 = randomChars[Math.floor(Math.random() * randomChars.length)];
                
                return `<span class="text-scramble-char" 
                            data-char="${char}" 
                            data-char-1="${char1}" 
                            data-char-2="${char2}" 
                            data-char-3="${char3}"
                            style="--char-index: ${indexInLine};">${char}</span>`;
            }).join('');
        }).join('');
        
        element.innerHTML = html;
        element.classList.add('text-scramble-prepared');
    }
    
    // Подготавливаем все текстовые элементы
    function prepareAllTextElements() {
        const titleElements = document.querySelectorAll('[data-gallery-text="title"]');
        const authorElements = document.querySelectorAll('[data-gallery-text="author"]');
        
        titleElements.forEach(prepareTextForScramble);
        authorElements.forEach(prepareTextForScramble);
    }
    
    // Функция для активации эффекта scrambling
    function activateScrambleEffect(container) {
        if (!container) return;
        
        const titleElement = container.querySelector('[data-gallery-text="title"]');
        const authorElement = container.querySelector('[data-gallery-text="author"]');
        
        if (titleElement) {
            prepareTextForScramble(titleElement);
            titleElement.classList.add('text-scramble-active');
        }
        
        if (authorElement) {
            prepareTextForScramble(authorElement);
            authorElement.classList.add('text-scramble-active');
        }
    }
    
    // Функция для деактивации эффекта scrambling
    function deactivateScrambleEffect() {
        const activeElements = document.querySelectorAll('.text-scramble-active');
        activeElements.forEach(element => {
            element.classList.remove('text-scramble-active');
        });
    }
    
    // Инициализация при загрузке страницы
    document.addEventListener('DOMContentLoaded', () => {
        prepareAllTextElements();
        
        // Скрываем все тексты во время начальной анимации
        document.body.classList.add('initial-animation');
    });
    
    // Обработчики событий для анимации текста
    document.addEventListener('galleryTransitionStart', () => {
        // Сначала деактивируем текущий эффект scrambling
        deactivateScrambleEffect();
        
        // Затем активируем эффект для нового слайда
        const activeSlide = document.querySelector('.swiper-slide-active');
        if (activeSlide) {
            activateScrambleEffect(activeSlide);
        }
    });
    
    // Добавляем обработчик завершения перехода
    document.addEventListener('galleryTransitionComplete', () => {
        // Деактивируем текущий эффект scrambling
        deactivateScrambleEffect();
        
        // Активируем эффект для текущего слайда
        const activeSlide = document.querySelector('.swiper-slide-active');
        if (activeSlide) {
            activateScrambleEffect(activeSlide);
        }
    });
    
    // Обработчик события завершения начальной анимации
    document.addEventListener('galleryInitialAnimationComplete', () => {
        // Показываем тексты после завершения начальной анимации
        document.body.classList.remove('initial-animation');
        
        const activeSlide = document.querySelector('.swiper-slide-active');
        if (activeSlide) {
            activateScrambleEffect(activeSlide);
        }
    });
    
    return {
        prepareAllTextElements,
        activateScrambleEffect,
        deactivateScrambleEffect
    };
}

// Инициализируем эффект scrambling
const textScrambleEffect = setupTextScrambleEffect();

// Шейдеры встроены в скрипт
const VERTEX_SHADER = `
attribute vec4 aPosition;
attribute vec2 aTexCoord;
varying vec2 vUv;
varying vec2 vScreenPosition;

void main() {
    gl_Position = aPosition;
    vUv = aTexCoord;
    vScreenPosition = aPosition.xy;
}`;

const FRAGMENT_SHADER = `
precision highp float;

uniform float uTime;
uniform vec2 uResolution;
uniform sampler2D uTexture;
uniform sampler2D uTextureNext;
uniform float uTransition;
uniform vec2 uMousePosition;
uniform float uDirection;
varying vec2 vUv;
varying vec2 vScreenPosition;

#define PI 3.1415926535897932384626433832795

vec3 obj_pos = vec3(0.0, 0.0, -10.0);
float obj_size = 5.0;

vec3 getFishEye(vec2 uv, float level) {
    float len = length(uv);
    float a = len * level;
    return vec3(uv / len * sin(a), -cos(a));
}

vec3 textureAVG(sampler2D tex, vec2 tc) {
    const float diff0 = 0.35;
    const float diff1 = 0.12;
    vec2 flippedCoord = vec2(tc.x, 1.0 - tc.y);
    vec3 s0 = texture2D(tex, flippedCoord).xyz;
    vec3 s1 = texture2D(tex, (vec2(flippedCoord.x + diff0, flippedCoord.y))).xyz;
    vec3 s2 = texture2D(tex, (vec2(flippedCoord.x - diff0, flippedCoord.y))).xyz;
    vec3 s3 = texture2D(tex, (vec2(flippedCoord.x - diff0, flippedCoord.y + diff0))).xyz;
    vec3 s4 = texture2D(tex, (vec2(flippedCoord.x + diff0, flippedCoord.y - diff0))).xyz;
    
    vec3 s5 = texture2D(tex, (vec2(flippedCoord.x + diff1, flippedCoord.y))).xyz;
    vec3 s6 = texture2D(tex, (vec2(flippedCoord.x - diff1, flippedCoord.y))).xyz;
    vec3 s7 = texture2D(tex, (vec2(flippedCoord.x - diff1, flippedCoord.y + diff1))).xyz;
    vec3 s8 = texture2D(tex, (vec2(flippedCoord.x + diff1, flippedCoord.y - diff1))).xyz;
    
    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;
}

vec3 getColor(vec3 ray, sampler2D tex) {
    vec2 baseUV = ray.xy;
    baseUV = (baseUV + 1.0) * 0.5;
    
    float containerAspect = uResolution.x / uResolution.y;
    float scale = 1.0;
    
    if (containerAspect < 1.0) {
        scale = containerAspect;
        baseUV.x = baseUV.x * scale + (1.0 - scale) * 0.5;
    } else {
        scale = 1.0 / containerAspect;
        baseUV.y = baseUV.y * scale + (1.0 - scale) * 0.5;
    }
    
    baseUV.y = 1.0 - baseUV.y;
    vec3 baseColor = texture2D(tex, baseUV).xyz;
    return baseColor;
}

void main() {
    vec2 uv = vScreenPosition.xy;
    vec3 dir = getFishEye(uv, 1.4);
    vec3 color;
    
    // Горизонтальное и вертикальное движение
    float mouseX = -(uMousePosition.x - 0.5);
    float mouseY = -(uMousePosition.y - 0.5); // Добавляем вертикальное движение
    float mouseInfluenceX = 0.3; // Горизонтальное влияние
    float mouseInfluenceY = 0.2; // Уменьшенное вертикальное влияние
    
    // Создаем матрицы поворота для обоих направлений
    float mouseRotationX = mouseX * mouseInfluenceX * PI;
    float mouseRotationY = mouseY * mouseInfluenceY * PI;
    
    float transitionRotation = uTransition * PI * 2.0 * uDirection;
    
    // Матрица для горизонтального поворота
    mat2 mouseRotationMatrixX = mat2(
        cos(mouseRotationX), -sin(mouseRotationX),
        sin(mouseRotationX), cos(mouseRotationX)
    );
    
    // Матрица для вертикального поворота
    mat2 mouseRotationMatrixY = mat2(
        cos(mouseRotationY), -sin(mouseRotationY),
        sin(mouseRotationY), cos(mouseRotationY)
    );
    
    mat2 transitionRotationMatrix = mat2(
        cos(transitionRotation), -sin(transitionRotation),
        sin(transitionRotation), cos(transitionRotation)
    );
    
    // Применяем оба поворота
    dir.xz = mouseRotationMatrixX * dir.xz;  // горизонтальный поворот
    dir.yz = mouseRotationMatrixY * dir.yz;  // вертикальный поворот
    dir.xz = transitionRotationMatrix * dir.xz;
    
    // Плавное смешивание текстур
    vec3 currentColor = getColor(dir, uTexture);
    vec3 nextColor = getColor(dir, uTextureNext);
    
    // Используем простой линейный переход вместо сложной логики с модулем угла
    float mixFactor = smoothstep(0.0, 1.0, uTransition);
    
    // Смешиваем текстуры
    color = mix(currentColor, nextColor, mixFactor);
    
    float fish_eye = smoothstep(2.0, 1.6, length(uv)) * 0.15 + 0.85;
    gl_FragColor = vec4(color * fish_eye, 1.0);
}
`;

class CircularGallery {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl');
        if (!this.gl) {
            console.error('WebGL not supported');
            return;
        }

        // Добавляем класс preload к canvas для предотвращения анимации
        this.canvas.classList.add('preload');

        this.currentImage = null;
        this.startTime = performance.now();
        this.isInitialized = false;
        this.initialAnimationPlayed = false; // Добавляем флаг для отслеживания начальной анимации
        this.isInitialAnimationPlaying = false; // Флаг для блокировки обработки движения мыши во время начальной анимации
        
        // Инициализация переменных для отслеживания позиции мыши
        this.mousePosition = { x: 0.5, y: 0.5 };
        this.targetMousePosition = { x: 0.5, y: 0.5 };
        
        // Добавляем обработчики событий мыши на window
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (!isMobile) {
            window.addEventListener('mousemove', this.handleMouseMove.bind(this));
        }
        
        // Добавляем параметры для перехода
        this.params = {
            distortionStrength: 0,
            transition: 0,
            animationSpeed: 0,
            direction: 1 // 1 для вправо, -1 для влево
        };
        
        this.nextTexture = null;
        this.isTransitioning = false;
        
        this.isAnimating = true; // Начинаем с активной анимацией
        this.animationFrameId = null;
        this.lastMouseMoveTime = 0;
        this.mouseMoveTolerance = 0.0001;
        this.lastRenderTime = 0;
        this.needsConstantRender = true; // Флаг для постоянного рендеринга
        
        // Добавляем стили для предотвращения анимации при загрузке
        const style = document.createElement('style');
        style.textContent = `
            canvas[data-gallery="container"].preload {
                animation: none !important;
                transition: none !important;
            }
            canvas[data-gallery="container"].preload * {
                animation: none !important;
                transition: none !important;
            }
            
            /* Добавляем стили для управления навигацией */
            [data-gallery="swiper-nav"] {
                visibility: hidden;
                opacity: 0;
            }
            [data-gallery="swiper-nav"].visible {
                transition: visibility 0.3s linear, opacity 0.6s linear;
                visibility: visible;
                opacity: 1;
            }
        `;
        document.head.appendChild(style);
        
        // Инициализация WebGL
        this.initWebGL();
        
        // Добавляем обработчик изменения размера окна
        window.addEventListener('resize', () => {
            this.startRenderLoop();
            // Останавливаем рендер через 100мс после последнего ресайза
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                if (!this.isTransitioning && !this.isMouseMoving()) {
                    this.stopRenderLoop();
                }
            }, 100);
        });
        
        // Немедленно загружаем первое изображение
        this.loadImage();
    }
    
    // Добавляем методы управления рендер-циклом
    startRenderLoop() {
        if (!this.isAnimating) {
            this.isAnimating = true;
            this.animate(performance.now());
        }
    }
    
    stopRenderLoop() {
        // Не останавливаем рендеринг, если он необходим постоянно
        if (this.needsConstantRender) return;
        
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        this.isAnimating = false;
    }
    
    isMouseMoving() {
        const now = performance.now();
        const timeSinceLastMove = now - this.lastMouseMoveTime;
        return timeSinceLastMove < 100;
    }
    
    handleMouseMove(event) {
        // Если идет начальная анимация, игнорируем движение мыши
        if (this.isInitialAnimationPlaying) return;
        
        const x = event.clientX / window.innerWidth;
        const y = 1 - event.clientY / window.innerHeight;
        
        this.targetMousePosition = {
            x: gsap.utils.clamp(0, 1, x),
            y: gsap.utils.clamp(0, 1, y)
        };
    }

    async updateImage(newImage, skipAnimation = false) {
        if (!this.gl || !newImage) {
            console.warn('GL context or image not available');
            return;
        }

        // Если это первое изображение или контекст не инициализирован
        if (!this.isInitialized || !this.currentImage) {
            this.gl.activeTexture(this.gl.TEXTURE0);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
            this.currentImage = newImage;
            this.isInitialized = true;
            this.startTime = performance.now();
            this.animate(this.startTime);
            return;
        }

        if (this.currentImage && this.currentImage.src === newImage.src) {
            return;
        }

        if (this.isTransitioning) {
            return;
        }

        this.isTransitioning = true;

        // Используем программу перед установкой униформ
        this.gl.useProgram(this.program);

        // Всегда загружаем новое изображение в следующую текстуру
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
        this.gl.uniform1i(this.textureNextLocation, 1);

        if (skipAnimation) {
            this.gl.activeTexture(this.gl.TEXTURE0);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
            this.currentImage = newImage;
            this.isTransitioning = false;
            this.stopRenderLoop();
            return;
        }

        this.startRenderLoop();
        
        gsap.timeline()
            .to(this.params, {
                transition: 1,
                duration: 1.2,
                ease: "power2.inOut",
                onStart: () => {
                    // Триггерим событие начала перехода
                    const event = new CustomEvent('galleryTransitionStart', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    });
                    this.canvas.dispatchEvent(event);
                    // Также диспатчим событие на document для удобства
                    document.dispatchEvent(new CustomEvent('galleryTransitionStart', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    }));
                },
                onUpdate: () => {
                    this.gl.useProgram(this.program);
                    this.gl.uniform1f(this.transitionLocation, this.params.transition);
                    this.gl.uniform1f(this.directionLocation, this.params.direction);
                },
                onComplete: () => {
                    // По завершении анимации обновляем текущую текстуру
                    this.gl.activeTexture(this.gl.TEXTURE0);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
                    this.currentImage = newImage;
                    this.params.transition = 0;
                    this.isTransitioning = false;
                    
                    // Очищаем следующую текстуру
                    this.gl.activeTexture(this.gl.TEXTURE1);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
                    
                    // Триггерим событие завершения перехода
                    const event = new CustomEvent('galleryTransitionComplete', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    });
                    this.canvas.dispatchEvent(event);
                    // Также диспатчим событие на document для удобства
                    document.dispatchEvent(new CustomEvent('galleryTransitionComplete', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    }));
                    
                    // Проверяем необходимость продолжения рендеринга
                    if (!this.needsConstantRender && !this.isMouseMoving()) {
                        this.stopRenderLoop();
                    }
                }
            });
    }

    async loadImage() {
        // Получаем все изображения галереи
        const galleryImages = document.querySelectorAll('[data-gallery="image"]');
        if (galleryImages.length === 0) {
            return;
        }

        // Находим первое реальное изображение (не плейсхолдер)
        let firstRealImage = null;
        for (let i = 0; i < galleryImages.length; i++) {
            const img = galleryImages[i];
            // Проверяем, что это не плейсхолдер
            if (img.src && !img.src.includes('placeholder')) {
                firstRealImage = img;
                break;
            }
        }

        if (!firstRealImage && galleryImages.length > 0) {
            firstRealImage = galleryImages[0];
        }

        if (!firstRealImage) {
            return;
        }

        try {
            console.log('Loading first image:', firstRealImage.src);
            const img = await imageLoader.load(firstRealImage.src);
            
            if (img) {
                console.log('First image loaded successfully');
                this.currentImage = img;
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
                this.isInitialized = true;

                // Копируем изображение в следующую текстуру для начальной анимации
                this.gl.activeTexture(this.gl.TEXTURE1);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
                
                this.startTime = performance.now();
                this.animate(this.startTime);

                // Запускаем начальную анимацию после полной инициализации
                requestAnimationFrame(() => {
                    this.playInitialAnimation();
                });
            } else {
                console.error('Failed to load first image');
                this.isInitialized = true;
            }
        } catch (error) {
            console.error('Error loading first image:', error);
            this.isInitialized = true;
        }
    }

    playInitialAnimation() {
        if (this.initialAnimationPlayed || !this.isInitialized) return;
        
        console.log('Starting initial animation');
        
        // Убеждаемся, что все необходимые параметры инициализированы
        if (!this.gl || !this.program || !this.transitionLocation || !this.directionLocation) {
            console.error('WebGL not fully initialized');
            return;
        }

        // Сохраняем начальную позицию мыши (центр)
        const centerPosition = { x: 0.5, y: 0.5 };
        this.mousePosition = { ...centerPosition };
        this.targetMousePosition = { ...centerPosition };
        
        // Блокируем обработку движения мыши на время анимации
        this.isInitialAnimationPlaying = true;
        
        // Принудительно запускаем рендер-цикл
        this.startRenderLoop();
        this.isTransitioning = true;
        
        // Запускаем два полных оборота
        gsap.timeline()
            .fromTo(this.params, 
                {
                    transition: 0,
                    direction: -1
                },
                {
                    transition: 2, // Два полных оборота
                    duration: 2.5,
                    ease: "back.inOut",
                    onStart: () => {
                        console.log('Initial animation started');
                    },
                    onUpdate: () => {
                        if (!this.gl || !this.program) return;
                        this.gl.useProgram(this.program);
                        this.gl.uniform1f(this.transitionLocation, this.params.transition);
                        this.gl.uniform1f(this.directionLocation, this.params.direction);
                    },
                    onComplete: () => {
                        console.log('Initial animation completed');
                        this.params.transition = 0;
                        this.isTransitioning = false;
                        this.initialAnimationPlayed = true;
                        this.isInitialAnimationPlaying = false; // Разблокируем обработку движения мыши
                        this.canvas.classList.remove('preload');
                        
                        // Показываем навигацию вместе с текстом
                        const swiperElement = document.querySelector('[data-gallery="swiper-nav"]');
                        if (swiperElement) {
                            swiperElement.classList.add('visible');
                        }
                        
                        // Диспатчим событие завершения начальной анимации
                        const event = new CustomEvent('galleryInitialAnimationComplete');
                        document.dispatchEvent(event);
                        
                        if (!this.needsConstantRender && !this.isMouseMoving()) {
                            this.stopRenderLoop();
                        }
                    }
                }
            );
    }

    createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    initWebGL() {
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, VERTEX_SHADER);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, FRAGMENT_SHADER);

        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader);
        this.gl.attachShader(this.program, fragmentShader);
        this.gl.linkProgram(this.program);

        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
            console.error('Program link error:', this.gl.getProgramInfoLog(this.program));
            return;
        }

        // Создаем и инициализируем буферы
        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1,
        ]);

        const texCoords = new Float32Array([
            0, 1,
            1, 1,
            0, 0,
            1, 0,
        ]);

        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

        this.texCoordBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);

        // Получаем локации атрибутов и униформ
        this.positionLocation = this.gl.getAttribLocation(this.program, 'aPosition');
        this.texCoordLocation = this.gl.getAttribLocation(this.program, 'aTexCoord');
        this.timeLocation = this.gl.getUniformLocation(this.program, 'uTime');
        this.resolutionLocation = this.gl.getUniformLocation(this.program, 'uResolution');
        this.mousePositionLocation = this.gl.getUniformLocation(this.program, 'uMousePosition');

        // Создаем и настраиваем текстуру
        this.texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        
        // Устанавливаем параметры текстуры
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        
        // Создаем пустую текстуру нужного размера
        const width = 1;
        const height = 1;
        const pixels = new Uint8Array([0, 0, 0, 255]);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);

        // Создаем текстуру для следующего изображения
        this.nextTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        
        // Создаем пустую текстуру
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);

        // Получаем локации униформ для перехода
        this.transitionLocation = this.gl.getUniformLocation(this.program, 'uTransition');
        this.textureNextLocation = this.gl.getUniformLocation(this.program, 'uTextureNext');
        this.directionLocation = this.gl.getUniformLocation(this.program, 'uDirection');
    }

    resizeCanvas() {
        const displayWidth = this.canvas.clientWidth;
        const displayHeight = this.canvas.clientHeight;

        if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
            this.canvas.width = displayWidth;
            this.canvas.height = displayHeight;
            this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
        }
    }

    render(time) {
        this.resizeCanvas();

        const interpolationFactor = 0.1;
        this.mousePosition.x += (this.targetMousePosition.x - this.mousePosition.x) * interpolationFactor;
        this.mousePosition.y += (this.targetMousePosition.y - this.mousePosition.y) * interpolationFactor;

        this.gl.clearColor(0, 0, 0, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);

        if (!this.currentImage) return;

        this.gl.useProgram(this.program);

        // Устанавливаем униформы
        this.gl.uniform1f(this.timeLocation, (time - this.startTime) / 1000);
        this.gl.uniform2f(this.resolutionLocation, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform2f(this.mousePositionLocation, this.mousePosition.x, this.mousePosition.y);
        this.gl.uniform1f(this.transitionLocation, this.params.transition);
        this.gl.uniform1f(this.directionLocation, this.params.direction);

        // Активируем и привязываем текстуры
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'uTexture'), 0);

        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
        this.gl.uniform1i(this.textureNextLocation, 1);

        // Устанавливаем атрибуты и рисуем
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.enableVertexAttribArray(this.texCoordLocation);
        this.gl.vertexAttribPointer(this.texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);

        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }

    animate(time) {
        if (!this.isAnimating) return;
        
        this.render(time);
        
        // Всегда продолжаем анимацию, если требуется постоянный рендеринг
        if (this.needsConstantRender || this.isTransitioning || this.isMouseMoving()) {
            this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
        } else {
            this.stopRenderLoop();
        }
    }
}

// Инициализация при загрузке страницы
window.addEventListener('DOMContentLoaded', () => {
    window.circularGalleries = [];
    
    function initializeGallery() {
        const canvases = document.querySelectorAll('canvas[data-gallery="container"]');
        const galleryImages = document.querySelectorAll('[data-gallery="image"]');
        
        if (canvases.length === 0) {
            return false;
        }
        
        canvases.forEach(canvas => {
            if (canvas.hasAttribute('data-gallery-initialized')) {
                return;
            }
            
            const gallery = new CircularGallery(canvas);
            canvas.setAttribute('data-gallery-initialized', 'true');
            window.circularGalleries.push(gallery);
            
            canvas.addEventListener('galleryImageChange', async (event) => {
                if (event.detail && event.detail.imageUrl) {
                    try {
                        const img = await imageLoader.load(event.detail.imageUrl);
                        gallery.updateImage(img);
                    } catch (error) {
                        console.error('Failed to load image:', error);
                    }
                }
            });
        });
        
        return true;
    }
    
    // Пытаемся инициализировать сразу
    let initialized = initializeGallery();
    
    if (!initialized) {
        // Если не удалось, пробуем еще раз после короткой задержки
        requestAnimationFrame(() => {
            initialized = initializeGallery();
        });
    }
    
    // Инициализируем Swiper с задержкой
    setTimeout(initializeSwiperGallery, 500);
});

function initializeSwiperGallery() {
    if (typeof Swiper === 'undefined') {
        console.error('Swiper is not loaded');
        return;
    }

    const swiperElement = document.querySelector('[data-gallery="swiper"]');
    if (!swiperElement) return;

    try {
        const swiper = new Swiper('[data-gallery="swiper"]', {
            wrapperClass: 'swiper-cover_wrapper',
            slideClass: 'swiper-cover_slide',
            slidesPerView: 1,
            spaceBetween: 0,
            loop: true,
            effect: "fade",
            fadeEffect: { crossFade: true },
            observer: true,
            observeParents: true,
            touchEventsTarget: 'wrapper',
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            reverseDirection: true,
            navigation: {
                nextEl: '[data-gallery="next"]',
                prevEl: '[data-gallery="prev"]'
            },
            pagination: {
                el: '.swiper-pagination',
                clickable: true,
            },
            on: {
                navigationNext: function() {
                    if (window.circularGalleries?.[0]) {
                        window.circularGalleries[0].params.direction = -1;
                    }
                },
                navigationPrev: function() {
                    if (window.circularGalleries?.[0]) {
                        window.circularGalleries[0].params.direction = 1;
                    }
                },
                touchStart: function() {
                    const startX = this.touches.startX;
                    this.on('touchMove', () => {
                        if (window.circularGalleries?.[0]) {
                            window.circularGalleries[0].params.direction = 
                                this.touches.currentX - startX > 0 ? -1 : 1;
                        }
                    });
                },
                slideChange: function() {
                    const canvas = document.querySelector('[data-gallery="container"]');
                    const slides = Array.from(this.slides);
                    const activeSlide = slides[this.activeIndex];
                    const img = activeSlide.querySelector('[data-gallery="image"]');

                    if (canvas && img && !img.src.includes('placeholder')) {
                        const event = new CustomEvent('galleryImageChange', {
                            detail: { 
                                imageUrl: img.src,
                                direction: window.circularGalleries[0]?.params.direction
                            }
                        });
                        canvas.dispatchEvent(event);
                    }
                }
            }
        });
        window.gallerySwiper = swiper;
    } catch (error) {
        console.error('Swiper initialization error:', error);
    }
}

// Добавляем стиль для скрытия плейсхолдера
(function() {
    // Создаем стиль для скрытия плейсхолдера
    const style = document.createElement('style');
    style.textContent = `
        img[src*="placeholder.60f9b1840c.svg"] {
            opacity: 0 !important;
            visibility: hidden !important;
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            overflow: hidden !important;
        }
    `;
    document.head.appendChild(style);
    
    // Добавляем обработчик ошибок для всех изображений
    window.addEventListener('DOMContentLoaded', () => {
        const images = document.querySelectorAll('[data-gallery="image"]');
        images.forEach(img => {
            img.onerror = function() {
                // Если это плейсхолдер, игнорируем ошибку
                if (this.src && this.src.includes('placeholder')) {
                    return true;
                }
            };
        });
    });
})();